# データフロー安全性

本ドキュメントは、BT-DSL コンパイラにおけるデータフロー安全性（Data Flow Safety）チェックの実装について説明します。

---

## 1. 目的

BT-DSL の変数は、初期状態では Blackboard 上にエントリが存在しない（**Unset**）可能性があります。
Unset 状態の変数に対して読み取りアクセス（`in` ポートへの渡しなど）を行うと、実行時エラーが発生します。

本機能は、静的解析によって変数の状態（Set/Unset）を追跡し、Unset 変数への安全でないアクセスをコンパイル時に検出します。

---

## 2. 状態モデル

各変数は、プログラム内の各ポイントにおいて以下のいずれかの状態を持ちます。

| 状態      | 説明                                                                                   |
| :-------- | :------------------------------------------------------------------------------------- |
| **Unset** | 変数は未設定（Blackboard エントリ不在）。初期値のない宣言直後など。                    |
| **Set**   | 変数は設定済み（Blackboard エントリ存在）。値の読み取りが可能。                        |
| **Maybe** | 変数は設定されているかもしれないし、されていないかもしれない（条件分岐の合流後など）。 |

---

## 3. 基本原則

### 3.1 宣言時の状態

- 初期値なし宣言 (`var x: T;`): **Unset**
- 初期値あり宣言 (`var x: T = val;`): **Set**

### 3.2 ポート呼び出し時の制約

- `in` / `inout` ポート: 渡される変数は **Set** 状態でなければなりません。
- `out` ポート: 渡される変数は **Unset** / **Set** / **Maybe** いずれでも構いません。

### 3.3 ポート呼び出し後の遷移

ノードが **Success** を返した場合：

- `out` ポートに渡された変数 → **Set** に遷移
- `inout` ポートに渡された変数 → **Set** を維持（元々 Set であることが前提）
- `in` ポートに渡された変数 → 状態変化なし

ノードが **Failure** を返した場合：

- 変数の状態は変化しない（Unset は Unset のまま、Set は Set のまま）

### 3.4 条件付き実行と絞り込み

`@guard(is_set(x))` などの条件式によって、スコープ内で変数の状態を絞り込むことができます。

- `is_set(x)` が真であるパス: `x` は **Set**
- `is_set(x)` が偽であるパス: `x` は **Unset**

---

## 4. `#[behavior]` 属性によるフロー解析

コンパイラは、制御ノードに付与された `#[behavior]` 属性を利用して、変数の状態変化を追跡します。

### 4.1 DataPolicy（データ合流ルール）

親ノードが **Success** で完了した後の、子ノードによる書き込み状態の扱いを規定します。

| Policy | 説明                                                                                                                                             |
| :----- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
| `All`  | **和集合**: すべての子が実行され成功したとみなす（例: `Sequence`）。<br>子がそれぞれ `x`, `y` を Set した場合、親終了後は `x`, `y` 両方が Set。  |
| `Any`  | **共通部分**: いずれかの子が成功したとみなす（例: `Fallback`）。<br>すべての子で共通して Set される変数のみが Set となる。それ以外は **Maybe**。 |
| `None` | **破棄**: 子による書き込み保証はない（例: `ForceSuccess`）。<br>親終了後、子で Set された変数は **Maybe**（元の状態が Unset なら）となる。       |

### 4.2 FlowPolicy（実行順序ルール）

子ノード間での状態伝播を規定します。

| Policy     | 説明                                                                                                                       |
| :--------- | :------------------------------------------------------------------------------------------------------------------------- |
| `Chained`  | **順次**: 前の子の実行結果（Set状態）が次の子に伝播する（例: `Sequence`）。                                                |
| `Isolated` | **独立**: すべての子は、親開始時点の状態のみを参照できる（例: `Parallel`）。<br>並列実行されるノード間での依存関係を防ぐ。 |

---

## 5. コード例

### 5.1 基本的な追跡

```bt-dsl
tree Main() {
  var x: int32;  // Unset

  // Error: Unset 変数を in ポートに渡している
  Use(val: in x);

  // OK: out ポートへの渡しは Unset でも可
  Create(res: out x);

  // Success パスでは x は Set
  Use(val: in x);
}
```

### 5.2 分岐と合流 (Fallback / Any)

```bt-dsl
Fallback {
  TaskA(res: out x);
  TaskB(res: out x);
}
// ここでは x は Set (両方のパスで Set されるため)
```

```bt-dsl
Fallback {
  TaskA(res: out x);
  TaskB(res: out y);
}
// ここでは x, y は Maybe (どちらか片方しか実行されないため)
// 次の行でエラー/警告
Use(val: in x);
```

### 5.3 存在チェックによるガード

```bt-dsl
tree SafeUse() {
  var target: Pose; // Unset

  FindTarget(out target); // 失敗する可能性がある -> target は Maybe

  @guard(is_set(target))
  MoveTo(in target); // OK: このスコープ内では target は Set
}
```

---

## 6. 警告レベル

| 状況                                  | 重大度           |
| :------------------------------------ | :--------------- |
| **Unset** 変数へのアクセス            | エラーまたは警告 |
| **Maybe** 変数へのアクセス            | 警告             |
| 初期化されていない `out` 変数の未使用 | 警告             |

診断の重大度は処理系のオプション（例: `--no-data-flow-check`）で制御可能にできます。
