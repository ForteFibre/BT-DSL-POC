# 型システム

本ドキュメントは BT-DSL の**型システム**を厳密に定義します。

---

## 1. 型の分類

### 1.1 基本型 (Primitive Types)

| 型カテゴリ | 型名              | ビット幅 | 説明                           |
| :--------- | :---------------- | :------- | :----------------------------- |
| 整数       | `int8`, `uint8`   | 8-bit    | 符号付き/なし整数              |
| 整数       | `int16`, `uint16` | 16-bit   | 符号付き/なし整数              |
| 整数       | `int32`, `uint32` | 32-bit   | 符号付き/なし整数（標準整数）  |
| 整数       | `int64`, `uint64` | 64-bit   | 符号付き/なし整数              |
| 浮動小数   | `float32`         | 32-bit   | 単精度浮動小数点数             |
| 浮動小数   | `float64`         | 64-bit   | 倍精度浮動小数点数（標準小数） |
| その他     | `bool`            | -        | 真偽値 (`true`, `false`)       |
| その他     | `string`          | -        | UTF-8 文字列                   |
| その他     | `string<=N`       | -        | 最大 N 文字の UTF-8 文字列     |

### 1.2 エイリアス (Aliases)

エイリアスは既存の型に別の名前を付ける機能です。完全に透過的であり、元の型と等価として扱われます。

#### 1.2.1 組み込みエイリアス

利便性のため、以下のエイリアスが定義済みです：

| エイリアス      | 実体型    |
| :-------------- | :-------- |
| `byte` / `char` | `uint8`   |
| `int`           | `int32`   |
| `float`         | `float32` |
| `double`        | `float64` |

#### 1.2.2 ユーザー定義エイリアス

`type` 文を使用して独自のエイリアスを定義できます。

```bt-dsl
type MyInt = int32;
type Points = vec<float64>;
```

### 1.3 配列型 (Array Types)

本セクションは、配列の扱いについて明示的なコスト管理を採用しています。

#### 1.3.1 静的配列 (Static Array)

##### 固定サイズ

- **型構文**: `[T; N]`
- **メモリ配置**: スタック（ローカル変数）または静的領域（グローバル変数）。ヒープ割り当ては発生しません。
- **特性**: 固定長。サイズ `N` は型の一部であり、異なるサイズの配列は異なる型として扱われます。

##### 上限付き（Bounded）

- **型構文**: `[T; <=N]`
- **メモリ配置**: 固定サイズと同様。最大 `N` 要素分のメモリを確保。
- **特性**: 最大 `N` 要素まで格納可能。コンパイル時にサイズ制約がチェックされます。

```bt-dsl
var fixed: [int32; 5];      // ちょうど5要素
var bounded: [int32; <=5];  // 最大5要素
```

#### 1.3.2 動的配列 (Dynamic Array)

- **型構文**: `vec<T>`
- **初期化構文**: `vec![1, 2, 3]` または `vec![0; 10]`
- **メモリ配置**: ヒープ（バッファへのポインタ、サイズ、キャパシティを管理）。
- **特性**: 可変長。実行時にリサイズ可能です。

#### 1.3.3 ワイルドカード (`_`)

型構文の一部として `_` を使用した場合、コンパイラは文脈からその部分の型を推論します。

- `vec<_>`: "動的配列であること" を指定し、要素型は初期値等から推論。
- `[_; 5]`: "サイズ5の静的配列であること" を指定し、要素型は推論。
- `[_; <=5]`: "最大5要素の静的配列であること" を指定し、要素型は推論。

### 1.4 推論用内部型 (Internal Types)

型推論プロセスでのみ存在する抽象型です。ソースコード上には現れません。

| 型          | 説明                                                            |
| :---------- | :-------------------------------------------------------------- |
| `{integer}` | 任意の整数型に解決可能なリテラル型（デフォルト: `int32`）       |
| `{float}`   | 任意の浮動小数型に解決可能なリテラル型（デフォルト: `float64`） |
| `?`         | 未解決の型変数                                                  |

### 1.5 外部型 (External Types)

`extern type` 宣言によって導入される型です。BT-DSL 内部では**不透明な型**（Opaque
Type）として扱われます。主にホストアプリケーション側で定義されたクラスや構造体を、BT-DSL 内で変数の型やポートの型として参照するために使用します。

- 内部構造にはアクセスできません（フィールドアクセスなどは不可）。
- 同名の外部型同士でのみ互換性を持ちます。他のいかなる型とも（明示的キャストを含め）変換できません。

### 1.6 定数型（Constant Types）

定数（`const`）は**コンパイル時定数**であり、グローバルスコープまたは tree 内のローカルスコープで宣言可能です。

- **初期化必須**: 定数は宣言時に
  `const_expr`（コンパイル時評価可能な式）で初期化されなければなりません。
- **イミュータブル**: 定数は変更できません。
- **型推論**: 変数と同様のルールに従います。
- **配列サイズへの使用**: 整数型の定数は静的配列のサイズ指定に使用できます。
- **定数の参照**: 定数式内で他の定数を参照できます（循環参照はエラー）。

```bt-dsl
const SIZE = 10;
const DOUBLE_SIZE = SIZE * 2;  // 他の定数を参照可能
var arr: int32[SIZE];          // SIZEは10に解決される

tree Example() {
    const LOCAL_SIZE = 5;      // ローカル定数も可能（コンパイル時定数のみ）
    var local_arr: int8[LOCAL_SIZE];
}
```

> [!IMPORTANT]
> ローカル定数もグローバル定数と同様に、コンパイル時に値が確定している必要があります。実行時の値（変数やパラメータ）を使用することはできません。

### 1.7 Nullable型

値が存在しない状態 (`null`) を許容する型です。

#### 1.7.1 構文

型名の接尾辞として `?` を付与することで Nullable 型を定義します。

```ebnf
type = base_type , [ "?" ] ;
```

#### 1.7.2 意味論

| 型                | 説明                                                          |
| :---------------- | :------------------------------------------------------------ |
| `T`（非Nullable） | 常に値を持つことが保証される。`null` の代入はコンパイルエラー |
| `T?`（Nullable）  | 型 `T` の値、または `null` を持つ可能性がある                 |

```bt-dsl
var pos: Pose;       // 非Nullable: 必ず値が必要
var target: Pose?;   // Nullable: null を許容
target = null;       // OK
pos = null;          // Error: 非Nullable に null は代入不可
```

#### 1.7.3 `null` リテラル

`null` はあらゆる Nullable 型 (`T?`) に代入可能なリテラルです。

#### 1.7.4 型推論との連携

**`null` 初期化による推論 (`_?`)**

変数が `null`
リテラルで初期化された場合、コンパイラはその型を「未解決の Nullable 型 (`_?`)」として扱います。ベース型
`T` は後続のコードでの使用から推論されます。

```bt-dsl
var target = null;   // 型は _?（未解決の Nullable）

Sequence {
    // SearchTarget(out Pose) への接続から、target は Pose? に確定
    SearchTarget(out target)
}
```

**明示的な Nullable 推論 (`: _?`)**

右辺が非 `null` 値であっても、変数を Nullable にしたい場合（後で `null`
を代入する可能性がある場合）、型注釈として `_?` を使用します。

```bt-dsl
var speed: _? = 1.0;  // 右辺は float だが、変数は float? になる
speed = null;         // OK（float? なので null 代入可）
```

**通常の推論**

右辺が非 `null` であり、型注釈がない場合、右辺の型（非Nullable）がそのまま適用されます。

```bt-dsl
var pos = GetPose();  // 型は Pose（非Nullable）
pos = null;           // Error: Pose 型に null は代入不可
```

#### 1.7.5 Nullable と初期化安全性

**すべての変数**に対して初期化安全性が**必須**となります。

- 非Nullable 変数は使用前に必ず初期化されている必要があります
- Nullable 変数は `null` で初期化することで未初期化状態を明示的に表現できます

詳細は[初期化安全性](./initialization-safety.md)を参照してください。

---

## 2. リテラルの型

リテラルは型推論プロセスで特別な扱いを受けます：

| リテラル種別     | 例              | 初期型      | デフォルト解決型 |
| :--------------- | :-------------- | :---------- | :--------------- |
| 整数リテラル     | `42`, `-7`, `0` | `{integer}` | `int32`          |
| 浮動小数リテラル | `3.14`, `-0.5`  | `{float}`   | `float64`        |
| 文字列リテラル   | `"hello"`, `""` | `string`    | `string`         |
| 真偽値リテラル   | `true`, `false` | `bool`      | `bool`           |
| null リテラル    | `null`          | `_?`        | 文脈から推論     |

### 2.1 配列リテラルの型推論

配列リテラルは、**デフォルトで静的配列として推論**されます。

| リテラル構文    | 推論される型 | 説明                             |
| :-------------- | :----------- | :------------------------------- |
| `[e1, e2, e3]`  | `[T; 3]`     | 要素数と同じサイズの静的配列     |
| `[e; N]`        | `[T; N]`     | 指定サイズ `N` の静的配列        |
| `vec![e1, ...]` | `vec<T>`     | 要素から推論される動的配列       |
| `vec![e; N]`    | `vec<T>`     | 指定サイズと初期値を持つ動的配列 |

> [!IMPORTANT]
>
> - 通常の配列リテラル `[...]` が「動的配列」になることはありません。動的配列が必要な場合は、`vec!`
>   構文を使用するか、型注釈/キャストで明示する必要があります。
> - **上限付き型 `[T; <=N]` はリテラルから推論されません。** 明示的な型注釈が必要です。

```bt-dsl
var a = [1, 2, 3];              // [int32; 3]（固定サイズ）
var b = [1.0, 2, 3.0];          // [float64; 3]
var c: [int8; 3] = [];          // [int8; 3]（文脈から推論）
var d: [int32; <=5] = [1, 2];   // [int32; <=5]（明示的注釈が必要）
```

### 2.2 上限付き型の文脈推論

ノード引数や代入のターゲット型が上限付き型の場合、リテラルはその型として検査されます。

```bt-dsl
extern action ProcessData(in arr: [int32; <=10]);

tree Example() {
    // リテラル [1, 2] は文脈から [int32; <=10] として扱われる
    ProcessData(arr: [1, 2]);

    var x: [int32; <=5];
    x = [1, 2, 3];  // リテラルは [int32; <=5] として検査される
}
```

### 2.3 文字列リテラルと上限付き文字列

```bt-dsl
var s = "hello";                // string（制限なし）
var t: string<=10 = "hello";    // string<=10（明示的注釈が必要）
var u: string<=3 = "hello";     // Error: 5文字 > 3
```

---

## 3. 型推論

制約に基づく双方向推論 (Constraint-based Bidirectional Inference) を採用します。

### 3.1 推論プロセス

1. **制約の収集**:
   - 変数宣言 `var x` は初期状態 `?` または `{integer}`/`{float}` で始まります。
   - `x` がノードのポートに接続される、または演算に使用されるたびに、型制約が追加されます。

2. **制約解決 (Unification)**:
   - 収集された制約を満たす、最も表現幅の小さい型（縮小変換が発生しない型）を探索します。
   - リテラル由来の値が、決定された型の範囲外である場合はエラーとなります。

3. **デフォルト適用**:
   - 制約が曖昧なままスコープを抜ける場合、デフォルト型（`int32` / `float64`）が適用されます。

### 3.2 推論の例

```bt-dsl
var val = 100;       // 初期: {integer}

// NodeA は `in: int8` ポートを持つ
NodeA(port: val);

// 結果: val は int8 に確定 (100 は int8 の範囲内)
```

### 3.3 ローカル変数の型決定

ローカル変数の型は以下の優先順位で決定されます：

1. **明示的な型注釈**がある場合: その型を使用
2. **初期値式**がある場合: 初期値の型から推論
3. **両方がある場合**: 型注釈が優先、初期値との互換性を検査
4. **型注釈も初期値もなく、制約も収集できない場合**: デフォルト型を適用

```bt-dsl
var x: int8 = 5      // 型は int8（明示）
var y = 3.14         // 型は float64（推論、デフォルト）
var z = 100          // 初期: {integer}、後続の使用で決定
```

### 3.4 グローバル変数の型決定

グローバル変数の型は以下の優先順位で決定されます：

1. **明示的な型注釈**がある場合: その型を使用
2. **初期値式**がある場合: 初期値の型から推論
3. **両方がある場合**: 型注釈が優先、初期値との互換性を検査
4. **両方がない場合**: 同一ファイル内の使用箇所から推論

> [!IMPORTANT]
> グローバル変数の型推論は**同一ファイル内**で完結する必要があります。ファイル内で型が一意に決定できない場合はコンパイルエラーとなります。

```bt-dsl
var x: int8 = 5;       // 型は int8（明示）
var y = 3.14;          // 型は float64（推論、デフォルト）
var z = [1, 2, 3];     // 型は [int32; 3]（推論）
var w: int32;          // 型は int32（明示、初期化なし → Uninit）
var v;                 // 型は同一ファイル内の使用から推論
```

### 3.5 グローバル定数の型決定

グローバル定数の型はローカル変数と同様のルールに従います。

```bt-dsl
const A = 42;          // 型は int32（デフォルト）
const B: int8 = 10;    // 型は int8（明示）
const C = A + 1;       // 型は int32（Aの型から推論）
```

---

## 4. 型変換

### 4.1 拡大変換 (Widening)

より大きな表現幅の型への変換は安全であり、値は維持されます。

| 変換元    | 変換先                       |
| :-------- | :--------------------------- |
| `int8`    | `int16`, `int32`, `int64`    |
| `uint8`   | `uint16`, `uint32`, `uint64` |
| `int16`   | `int32`, `int64`             |
| `uint16`  | `uint32`, `uint64`           |
| `int32`   | `int64`                      |
| `uint32`  | `uint64`                     |
| `float32` | `float64`                    |

### 4.2 縮小変換 (Narrowing)

より小さな表現幅の型への変換は情報落ちの可能性があります。

- **整数**: 上位ビット切り捨て (Wrap-around behavior)
- **浮動小数**: 精度低下または無限大への丸め

### 4.3 明示的キャスト (`as`)

`as` キーワードは、値を指定された型として扱います。

```bt-dsl
var small: int8 = large_value as int8;  // 縮小変換
var big: int32 = small_value as int32;  // 拡大変換
```

---

## 5. 型互換性

### 5.1 互換性規則まとめ

| 変換元 \ 変換先 | 同一型 | 拡大 (Widening) | 縮小 (Narrowing) | 配列           |
| :-------------- | :----: | :-------------: | :--------------: | :------------- |
| 代入 (`=`)      |   ✓    |    ✓ (暗黙)     |   ✗ (`as`必須)   | 型完全一致のみ |
| `in` 引数       |   ✓    |    ✓ (暗黙)     |   ✗ (`as`必須)   | 型完全一致のみ |
| `out` 引数      |   ✓    |    ✓ (暗黙)     |  ✗ (CICOで対応)  | 型完全一致のみ |
| `ref` 引数      |   ✓    | ✗ (CICOで対応)  |  ✗ (CICOで対応)  | 型完全一致のみ |
| 外部型          |   ✓    |        ✗        |        ✗         | 型完全一致のみ |

> [!NOTE] `ref`
> 引数では、拡大方向であっても書き戻し時に縮小が発生する可能性があるため、型が完全に一致しない場合は常に CICO 変換（`port as Type: ref var`）が必要です。

### 5.2 配列の代入・引数渡し

| 変換元 (Source) | 変換先 (Target)    | 判定     | 動作                                 |
| :-------------- | :----------------- | :------- | :----------------------------------- |
| `[T; N]`        | `[T; N]`           | OK       | 値コピー                             |
| `[T; N]`        | `[T; M]` (`N ≠ M`) | Error    | 型不一致                             |
| `[T; N]`        | `vec<T>`           | OK (注1) | 暗黙の拡大変換 (Allocation & Copy)   |
| `vec<T>`        | `[T; N]`           | Error    | 縮小変換不可                         |
| `vec<T>`        | `vec<T>`           | OK       | 参照コピーまたはクローン（実装依存） |

> [!NOTE] (注1) `in` ポートへの引数渡しの場合のみ: 静的配列を `in vec<T>`
> ポートに渡すことは安全であるため、暗黙的に許可されます。ただし、`out` / `ref`
> ポートの場合は型が厳密に一致する必要があります（静的配列をリサイズ可能な `ref vec<T>`
> として渡すことはできません）。

### 5.3 上限付き型の互換性

#### 5.3.1 上限付き静的配列

| 変換元     | 変換先     | 判定             | 説明                           |
| :--------- | :--------- | :--------------- | :----------------------------- |
| `[T; N]`   | `[T; <=M]` | OK if `N <= M`   | 固定サイズは上限内なら互換     |
| `[T; <=N]` | `[T; <=M]` | OK if `N <= M`   | 小さい上限から大きい上限へ     |
| `[T; <=N]` | `[T; <=M]` | Error if `N > M` | 大きい上限から小さい上限は不可 |
| `[T; <=N]` | `[T; M]`   | Error            | 上限付きから固定サイズは不可   |

#### 5.3.2 上限付き文字列

| 変換元      | 変換先      | 判定             | 説明                           |
| :---------- | :---------- | :--------------- | :----------------------------- |
| `string<=N` | `string<=M` | OK if `N <= M`   | 小さい上限から大きい上限へ     |
| `string<=N` | `string`    | OK               | 上限付きから制限なしへ         |
| `string`    | `string<=N` | Error            | 制限なしから上限付きは不可     |
| `string<=N` | `string<=M` | Error if `N > M` | 大きい上限から小さい上限は不可 |

```bt-dsl
extern action ProcessData(
    in data: [float64; <=10],
    in name: string<=32
);

tree Example() {
    var small: [float64; <=5] = [1.0, 2.0];
    var large: [float64; <=10] = [1.0, 2.0, 3.0];

    // OK: [float64; <=5] -> [float64; <=10]
    ProcessData(data: small, name: "test");

    // Error: [float64; <=10] を [float64; <=5] に渡すことは不可
}
```

### 5.4 使用例

```bt-dsl
extern ProcessStatic(in data: [float64; 4]);
extern ProcessDynamic(in data: vec<float64>);

var static_data = [1.0, 2.0, 3.0, 4.0]; // [float64; 4]

// 1. 静的 -> 静的
ProcessStatic(static_data);  // OK

// 2. 静的 -> 動的 (暗黙の変換)
ProcessDynamic(static_data); // OK: 一時的に vec が作られて渡される
ProcessDynamic([1.0, 2.0]);  // OK: [float64; 2] -> vec<float64> 変換

// 3. サイズ違い
ProcessStatic([1.0, 2.0]);   // Error: [float64; 2] は [float64; 4] に適合しない
```

### 5.4 暗黙の拡大 (Implicit Widening for Output)

`out` ポートの型より、受け取る変数の型が大きい場合、暗黙的に接続可能です。

```bt-dsl
var large: int32;
// NodeOut8 (out: int8) -> large (int32) : 安全
NodeOut8(port: large);
```

### 5.5 Copy-In / Copy-Out (CICO) 変換

型の不一致（縮小変換、または `ref` での型違い）がある場合、ポート名に `as`
を付与することでコンパイラが自動的に一時変数を生成し、書き戻し処理を行います。

**構文**: `Node(port as TargetType: ref variable)`

- `port as TargetType` で、ポートが受け取る型を指定
- `: ref variable` で、実際に渡す変数を指定

**動作**:

1. **Copy-In**: `variable` の値を `TargetType` にキャストし、一時変数 `_tmp` にコピーする。
2. **Execute**: ノードに `_tmp` の参照を渡して実行する。
3. **Copy-Out**: ノード実行終了後、`_tmp` の値を `variable` の型にキャストして代入（書き戻し）する。

**使用例**:

```bt-dsl
var a: int32 = 1000;

// a を int8 として NodeB に渡し、結果を a に戻す
// (実行中、a の値は int8 の範囲で切り捨てられ、書き戻される)
NodeB(ref_port as int8: ref a);
```

---

## 6. 変数宣言と型付け

### 6.1 デフォルト（静的配列）

型注釈を省略した場合、リテラルの型（静的配列）がそのまま適用されます。

```bt-dsl
var arr = [10, 20, 30];
// -> 型: [int32; 3]
// -> メモリ: スタック確保

arr = [1, 2];      // Error: 型 [int32; 3] に [int32; 2] は代入不可
```

### 6.2 動的配列の明示

動的配列を使用するには、`vec!` マクロを使用するか、型注釈で `vec` を指定します。

```bt-dsl
// vec! マクロを使用（推奨）
var v1 = vec![1, 2, 3];        // vec<int32>
var v2 = vec![0; 10];          // vec<int32> (サイズ10、初期値0)

// 型注釈による明示（リテラルからの暗黙変換）
var list: vec<int32> = [1, 2, 3];

// vec<_> で要素型を推論させる
var list_infer: vec<_> = [10, 20];
// -> 型: vec<int32> (右辺から推論)
```

---

## 7. 多次元配列

配列のネストも型定義に従って解決されます。

```bt-dsl
// 2x2 行列 (全て静的)
var mat2x2: [[int32; 2]; 2] = [[1, 2], [3, 4]];

// 動的配列の配列 (Jagged Array)
var jagged: vec<vec<int32>> = [
    [1, 2] as vec<_>,
    [3, 4, 5] as vec<_>
] as vec<_>;
```

---

## 8. 式の型付け規則

### 8.1 単項演算子

| 演算子 | オペランド型     | 結果型         |
| :----- | :--------------- | :------------- |
| `-`    | 任意の整数型     | 同じ整数型     |
| `-`    | 任意の浮動小数型 | 同じ浮動小数型 |
| `!`    | `bool`           | `bool`         |

上記以外の組み合わせは型エラーです。

### 8.2 二項演算子

#### 8.2.1 算術演算 (`+`, `-`, `*`, `/`)

同じ数値型同士の演算は同じ型を返します。異なる型の場合は、より大きな型に統一されます。

| 左オペランド | 右オペランド | 結果型    |
| :----------- | :----------- | :-------- |
| `int8`       | `int8`       | `int8`    |
| `int8`       | `int32`      | `int32`   |
| `float32`    | `float64`    | `float64` |

例外:

- `string + string` → `string`（文字列連結）

#### 8.2.2 剰余演算 (`%`)

整数型同士でのみ使用可能です。

| 左オペランド | 右オペランド | 結果型     |
| :----------- | :----------- | :--------- |
| 任意の整数型 | 同じ整数型   | 同じ整数型 |

#### 8.2.3 比較演算 (`<`, `<=`, `>`, `>=`)

| 左オペランド | 右オペランド | 結果型 |
| :----------- | :----------- | :----- |
| 数値型       | 数値型       | `bool` |

#### 8.2.4 等価演算 (`==`, `!=`)

| 左オペランド | 右オペランド | 結果型 |
| :----------- | :----------- | :----- |
| 任意の型     | 互換型       | `bool` |

オペランドが互換でない場合は型エラーです。

#### 8.2.5 論理演算 (`&&`, `||`)

| 左オペランド | 右オペランド | 結果型 |
| :----------- | :----------- | :----- |
| `bool`       | `bool`       | `bool` |

`bool` 以外のオペランドは型エラーです。

---

## 9. 配列アクセス

配列要素へのアクセスは `[]` 演算子を使用します。

```bt-dsl
var arr: [int32; 10];
var elem = arr[0];      // elem の型は int32
arr[5] = 100;           // 配列要素への代入
```

- インデックスは整数型（`int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`,
  `uint64`）でなければなりません。
- 配列型 `[T; N]` または `vec<T>` へのインデックスアクセスは型 `T` を返します。
