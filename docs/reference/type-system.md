# 3. 型システム（Type System）

本章は、BT-DSL における型（Type）を規定します。

---

## 3.1 基本型（Primitive Types）

### 3.1.1 整数型

| 符号付き | 符号なし |
| :------- | :------- |
| `int8`   | `uint8`  |
| `int16`  | `uint16` |
| `int32`  | `uint32` |
| `int64`  | `uint64` |

各整数型のビット幅は、型名末尾の数値に等しい固定値です。

### 3.1.2 浮動小数型

`float32`, `float64`

### 3.1.3 真偽値

`bool` — 値は `true` / `false` の 2 値です。

### 3.1.4 文字列

- `string` — UTF-8 文字列
- `string<N>` — 最大 N **バイト**の文字列型

`string<N>` の N は非負の整数であり、コンパイル時に定数として決定できなければなりません。

---

## 3.2 配列型（Array Types）

### 3.2.1 静的配列

- 固定長: `[T; N]` — ちょうど N 個の T を保持
- 上限付き: `[T; <=N]` — 最大 N 個までの T を保持

N はコンパイル時に定数として決定できなければなりません。

### 3.2.2 動的配列

`vec<T>` — 実行時に可変長の列として振る舞います。

### 3.2.3 多次元配列

配列はネストできます。外側から順に型コンストラクタを適用して得られる型です。

---

## 3.3 Nullable 型

`T?` は、型 T の値または `null` を取り得る型です。

- `T`（非 Nullable）に `null` を代入することはできません。
- `T?`（Nullable）には `null` を代入できます。

---

## 3.4 型エイリアス

`type Name = T;` により、型 T に対する別名 Name を定義できます。

- エイリアスは**透過的**でなければなりません。型検査において `Name` と `T` は区別されません。
- エイリアスの循環定義は禁止されます。

---

## 3.5 外部型（Opaque Types）

`extern type` により導入される型は不透明型です。

- BT-DSL からは内部構造にアクセスできません。
- 互換性は、名前解決後に**同一の `extern type` 宣言**を指すもの同士に限定されます。

---

## 3.6 型推論

### 3.6.1 リテラルの型推論

| リテラル種別     | 初期型      | デフォルト解決 |
| :--------------- | :---------- | :------------- |
| 整数リテラル     | `{integer}` | `int32`        |
| 浮動小数リテラル | `{float}`   | `float64`      |
| 文字列リテラル   | `string`    | `string`       |
| 真偽値リテラル   | `bool`      | `bool`         |
| `null` リテラル  | `_?`        | 文脈から推論   |

### 3.6.2 配列リテラル

- `[...]` は静的配列として推論されます。
- `vec![...]` は動的配列として推論されます。

### 3.6.3 型推論ワイルドカード

- `_` — 非 Nullable な型へ解決
- `_?` — Nullable 型へ解決

### 3.6.4 推論規則

推論は、以下の制約をすべて満たすように型を決定しなければなりません。

- 型注釈がある場合、変数の型はその注釈型に従う。
- 初期値がある場合、変数の型は初期値の型と互換でなければならない。
- スコープ終了時点で型が一意に定まらない場合、エラーとする。
  - ただし `{integer}` / `{float}` はデフォルト型（`int32` / `float64`）に解決される。

### 3.6.5 Blackboard / 定数の型決定

**`var` 宣言**:
1. 型注釈がある場合: 注釈型を採用
2. 初期値がある場合: 初期値式の型から推論
3. 両方ある場合: 型注釈を優先し、初期値が代入可能であることを検査
4. グローバル `var` は型注釈または初期値のいずれかが必須

**`const` 宣言**:
- 初期化必須
- 初期値は `const_expr` でなければなりません

---

## 3.7 互換性と変換

### 3.7.1 文脈の区別

| 文脈   | 説明                   | 適用規則         |
| :----- | :--------------------- | :--------------- |
| 値文脈 | 代入、`in` 引数        | 暗黙変換、`as`   |
| 参照文脈 | `ref` / `mut` 引数   | 完全一致のみ     |
| 出力文脈 | `out` 引数           | Output Widening  |

### 3.7.2 暗黙の拡大変換（Widening）

| 変換元    | 変換先                       |
| :-------- | :--------------------------- |
| `int8`    | `int16`, `int32`, `int64`    |
| `uint8`   | `uint16`, `uint32`, `uint64` |
| `int16`   | `int32`, `int64`             |
| `uint16`  | `uint32`, `uint64`           |
| `int32`   | `int64`                      |
| `uint32`  | `uint64`                     |
| `float32` | `float64`                    |

### 3.7.3 明示的キャスト（`as`）

縮小変換（例: `int32 -> int8`）は `as` が必須です。

### 3.7.4 配列の互換性

- `[T; N]` は `[T; N]` にのみ暗黙に代入可能
- `[T; N] -> [T; <=M]` は N ≤ M のときのみ許容
- `[T; <=N] -> [T; <=M]` は N ≤ M のときのみ許容
- 静的配列から動的配列への暗黙変換は禁止

### 3.7.5 上限付き文字列の互換性

- `string<N> -> string<M>` は N ≤ M のときのみ許容
- `string<N> -> string` は許容
- `string -> string<N>` は不許容

### 3.7.6 引数渡しにおける互換性

| 方向        | 同一型 | 拡大変換 | 縮小変換   |
| :---------- | :----: | :------: | :--------: |
| `in`        | ✓      | ✓        | `as` 必須  |
| `ref`/`mut` | ✓      | ✗        | ✗          |
| `out`       | ✓      | ✓ (Output Widening) | ✗ |

---

## 3.8 式の型規則

### 3.8.1 単項演算

- `-e` : 整数型または浮動小数型 → 同型
- `!e` : `bool` → `bool`

### 3.8.2 算術演算（`+`, `-`, `*`, `/`）

両オペランドを共通の型へ揃え、その型を結果型とします。

特例: `string + string` は `string`（文字列連結）

### 3.8.3 剰余（`%`）

両オペランドは整数型でなければなりません。

### 3.8.4 比較（`<`, `<=`, `>`, `>=`）

両オペランドは数値型。結果型は `bool` です。

### 3.8.5 等価（`==`, `!=`）

オペランド同士が値文脈で比較可能であること。結果型は `bool` です。

### 3.8.6 論理（`&&`, `||`）

両オペランドは `bool`。結果型は `bool` です。

### 3.8.7 ビット演算（`&`, `|`）

両オペランドは整数型。結果型は共通型です。

### 3.8.8 キャスト式

`e as T` — S から T への明示的キャストが許容される場合、結果型は T です。

### 3.8.9 配列アクセス

`arr[index]` — index は整数型、arr は配列型。結果型は要素型 T です。

**境界チェック**: 配列とインデックスがともにコンパイル時定数の場合、境界チェックはコンパイル時に行われます。
