# 意味制約

本ドキュメントは BT-DSL の**意味制約**（静的検査ルール）を厳密に定義します。

---

## 1. スコープと名前解決

### 1.1 スコープの種類

| スコープ      | 含まれる宣言                                                                                         |
| :------------ | :--------------------------------------------------------------------------------------------------- |
| グローバル    | `extern` 文 (Node), `extern type` 文, `type` 文 (Alias), グローバル変数, グローバル定数, `tree` 定義 |
| Tree ローカル | tree パラメータ、ローカル変数、ローカル定数                                                          |

### 1.2 名前解決の優先順位

識別子の解決は以下の順序で行われます：

1. Tree ローカル（パラメータ、ローカル変数、ローカル定数）
2. グローバル変数・グローバル定数

### 1.3 重複の禁止

同一スコープ内で同名の識別子を複数宣言することはできません。

| スコープ                 | 禁止される重複                                                                                                                          |
| :----------------------- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| グローバル（ノード）     | `extern` (Node) 同士 / `tree` 同士 / `extern` (Node) と `tree`                                                                          |
| グローバル（変数・定数） | グローバル変数同士 / グローバル定数同士 / グローバル変数とグローバル定数                                                                |
| グローバル（型）         | `extern type` 同士 / `type` (Alias) 同士 / `extern type` と `type` / 基本型・エイリアスとの衝突                                         |
| `extern` 内              | ポート同士                                                                                                                              |
| `tree` 内                | パラメータ同士 / ローカル変数同士 / ローカル定数同士 / パラメータとローカル変数 / パラメータとローカル定数 / ローカル変数とローカル定数 |

> [!NOTE]
>
> - ノード名（`extern`/`tree`）、変数・定数名、型名はそれぞれ独立した名前空間を持つため、同名でも衝突しません（例:
>   `extern type A;` と `tree A` は共存可能）。
> - グローバル変数・定数と tree 内の変数・定数（パラメータ/ローカル変数/ローカル定数）はスコープが異なるため、同名でも衝突しません（内側が優先されます）。

### 1.4 可視性（Visibility）

ファイル間の参照（インポート）におけるシンボルの可視性は、識別子の命名規則によって制御されます。

| 識別子の先頭文字     | 可視性      | 説明                                                       |
| :------------------- | :---------- | :--------------------------------------------------------- |
| `_` (アンダースコア) | **Private** | 定義されたファイル内でのみ参照可能。外部からは見えません。 |
| その他               | **Public**  | `import` した他のファイルから参照可能。                    |

> [!IMPORTANT] 型エイリアスにおける循環定義は禁止されます（例: `type A = B; type B = A;`）。

例：

- `tree _MyInternalTree` → Private（外部から隠蔽される）
- `tree MyPublicTree` → Public（外部から使用可能）

### 1.5 再帰呼び出しの禁止

`tree`
が自分自身を呼び出すこと（再帰呼び出し）は**禁止**されます。これには**間接的な再帰**も含まれます。

```bt-dsl
// 直接再帰: エラー
tree A() {
    A()  // エラー: tree A は自分自身を呼び出せません
}

// 間接再帰: エラー
tree B() {
    C()
}

tree C() {
    B()  // エラー: tree C -> tree B -> tree C の循環呼び出し
}
```

> [!NOTE] 再帰が禁止される理由：
>
> - `tree` の `out`
>   ポートの書き込み保証推論（Infer）において、再帰があると固定点が求まらない可能性がある
> - 型推論においても、再帰によって無限ループが発生する可能性がある
>
> コンパイラは呼び出しグラフを解析し、循環が検出された場合はコンパイルエラーを報告します。

---

## 2. ノードカテゴリ

### 2.1 有効なカテゴリ

`extern` 文の `category` は以下のいずれかでなければなりません：

```
action, condition, control, decorator, subtree
```

### 2.2 カテゴリ別の制約

各カテゴリのノードは、以下の構文規則に従う必要があります。

#### **action / condition / subtree**

- **構文**: `NodeName(...)`
- **丸括弧 `(...)`**: **必須**（引数がない場合でも `()` が必要）
- **子ブロック `{...}`**: **禁止**
- **`@[...]` 記法**: **禁止**

#### **control**

- **構文**: `NodeName(...) { ... }`
- **丸括弧 `(...)`**: **省略可能**（引数がない場合）
- **子ブロック `{...}`**: **必須**
- **`@[...]` 記法**: **禁止**

#### **decorator**

- **構文**: `@[NodeName(...)]`
- **丸括弧 `(...)`**: **省略可能**（引数がない場合）
- **子ブロック `{...}`**: **禁止**
- **`@[...]` 記法**: **必須**（`@` なしの呼び出しは不可、複数指定はカンマ区切り `@[Dec1, Dec2]`）

---

## 3. ポート方向の整合性

### 3.1 方向の定義

| 方向             | 意味                                     |
| :--------------- | :--------------------------------------- |
| `in`             | 読み取り専用（デフォルト）               |
| `out`            | 書き込み専用（成功時のみ書き込み）       |
| `out always`     | 書き込み専用（成功・失敗両方で書き込み） |
| `out on_failure` | 書き込み専用（失敗時のみ書き込み）       |
| `ref`            | 読み書き両用                             |

> [!NOTE] `out` ポートの書き込み保証修飾子（`always`, `on_failure`）は **`extern`
> 宣言でのみ**使用可能です。`tree` 定義の `out`
> ポートはコンパイラが内部を解析して自動推論するため、修飾子は不要です。詳細は[初期化安全性](./initialization-safety.md)を参照してください。

### 3.2 引数とポートの方向整合性

ノード呼び出し時、引数に指定された方向（`arg_dir`）と宣言ポートの方向（`port_dir`）は整合していなければなりません。

#### 整合性マトリクス

| `arg_dir` \ `port_dir` |   `in`    |   `out`   |  `ref`  |
| :--------------------- | :-------: | :-------: | :-----: |
| `in`（または省略）     |     ✓     |  ✗ Error  | ✗ Error |
| `out`                  |  ✗ Error  |     ✓     | ✗ Error |
| `ref`                  | ⚠ Warning | ⚠ Warning |    ✓    |

#### 詳細

- **`arg_dir = in`, `port_dir = out`**: Error
  - ポートは書き込みを要求するが、引数は読み取り専用
- **`arg_dir = in`, `port_dir = ref`**: Error
  - ポートは書き込み権限を要求するが、引数は読み取り専用
- **`arg_dir = out`, `port_dir = in`**: Error
  - ポートは読み取り専用だが、引数は書き込みを宣言
- **`arg_dir = out`, `port_dir = ref`**: Error
  - 厳密な一致が必要
- **`arg_dir = ref`, `port_dir = in`**: Warning
  - 書き込み意図があるが、ポートは読み取り専用のため無視される
- **`arg_dir = ref`, `port_dir = out`**: Warning
  - `out` を使用することを推奨

### 3.3 引数の種類と制約（LValue / RValue）

- **`in` ポートへの引数**: 任意の式（RValue）を使用できます。
- **`out` / `ref` ポートへの引数**: **左辺値（LValue）**でなければなりません。
  - 左辺値とは、変数、パラメータ、または配列要素など、値を代入可能な対象です。
  - リテラルや計算式（例: `a + b`）は右辺値であり、書き込み先として指定できません。
  - **定数**（`const`）は書き込み不可のため、`out` / `ref` 引数には使用できません。

### 3.4 tree パラメータの権限

引数が tree パラメータを参照する場合：

| パラメータ方向     | 引数に `out`/`ref` を付与 |
| :----------------- | :------------------------ |
| `in`（または省略） | **エラー**                |
| `out`              | 許可                      |
| `ref`              | 許可                      |

---

## 4. 型変換と引数渡し

### 4.1 暗黙の拡大 (Implicit Widening for Output)

`out` ポートの型より、受け取る変数の型が大きい場合、暗黙的に接続可能です。

```bt-dsl
var large: int32;
// NodeOut8 (out: int8) -> large (int32) : 安全
NodeOut8(port: large);
```

### 4.2 Copy-In / Copy-Out (CICO) 変換

型の不一致（縮小変換、または `ref` での型違い）がある場合、ポート名に `as`
を付与することでコンパイラが自動的に一時変数を生成し、書き戻し処理を行います。

**構文**: `Node(port as TargetType: ref variable)`

- `port as TargetType` で、ポートが受け取る型を指定
- `: ref variable` で、実際に渡す変数を指定

**使用例**:

```bt-dsl
var a: int32 = 1000;

// a を int8 として NodeB に渡し、結果を a に戻す
// (実行中、a の値は int8 の範囲で切り捨てられ、書き戻される)
NodeB(ref_port as int8: ref a);
```

静的配列から動的配列への変換を含む、型の不一致がある場合も同様の構文を使用します：

```bt-dsl
var arr: [int32; 2] = [1, 2];
// 静的配列 arr を動的配列 vec<int32> として渡す（ヒープ確保発生）
NodeProcess(data as vec<_>: ref arr);
```

---

## 5. 引数の制約

### 5.1 位置引数（positional argument）

- 位置引数は**最大1個**まで
- 位置引数を使用する場合、対象ノードのポート数は**ちょうど1**でなければならない

### 5.2 非左辺値（RValue）への方向指定

リテラルや計算結果などの右辺値（RValue）に対して、`out` または `ref` を付与することはできません。

```bt-dsl
NodeName(port: out 123)      // エラー: リテラルはRValue
NodeName(port: ref (a + b))  // エラー: 計算結果はRValue
```

> [!NOTE] `port as Type: direction variable` 構文は、CICO
> (Copy-In/Copy-Out) 変換のためにのみ使用可能です。詳細は[4.2 Copy-In / Copy-Out 変換](#4-2-copy-in-copy-out-cico-変換)を参照してください。

### 5.3 引数の省略規則

ノード呼び出し時、各ポートの省略可否は以下のルールに従います：

| ポート方向         | デフォルト値あり | デフォルト値なし |
| :----------------- | :--------------- | :--------------- |
| `in`（または省略） | 省略可能         | 省略不可         |
| `out`              | （設定不可）     | **常に省略可能** |
| `ref`              | （設定不可）     | **省略不可**     |

**動作の詳細:**

- **`in` ポート省略時**: デフォルト値が使用されます。
- **`out` ポート省略時**: 出力は破棄されます（一時変数に書き込まれ、無視される）。
- **`ref` ポート**: 常に左辺値を指定する必要があります。

```bt-dsl
extern action Example(
    in required: int32,
    in optional_in: int32 = 0,
    out result: int32,
    ref mandatory_ref: int32
);

tree Test() {
    var x: int32;
    var y: int32;

    // すべて指定
    Example(required: 1, optional_in: 2, result: out x, mandatory_ref: ref y);

    // in のデフォルト値と out の省略を使用
    Example(required: 1, mandatory_ref: ref y);  // optional_in=0, result は破棄

    // ref は省略不可
    // Example(required: 1);  // エラー: mandatory_ref が必須
}
```

### 5.4 デフォルト値の制約

- **`out` / `ref` ポートにはデフォルト値を指定できません。**
- **デフォルト値は定数式（`const_expr`）でなければなりません。**
  実行時の値（変数やパラメータ）は使用できません。
- **デフォルト値の型はポートの型と互換性が必要です。** 暗黙の型変換ルールが適用されます。

```bt-dsl
const DEFAULT_SPEED = 1.0;

extern action MoveTo(
    target: Vector3,
    speed: float = DEFAULT_SPEED,  // OK: in ポートにデフォルト値
    out result: bool,              // デフォルト値なし（禁止）
    ref state: int32               // デフォルト値なし（禁止）
);
```

---

## 6. 代入の制約

### 6.1 代入対象

代入文の左辺は以下のいずれかでなければなりません：

- ローカル変数
- グローバル変数
- `out` または `ref` として宣言された tree パラメータ
- 配列要素（例: `arr[0]`）

### 6.2 入力専用パラメータへの代入

`in` パラメータ（方向省略を含む）への代入は禁止されます。

### 6.3 定数への代入

定数（`const`）への代入は禁止されます。定数は宣言時に初期化され、その後は変更できません。

```bt-dsl
const MAX = 100;
MAX = 200;  // エラー: 定数への代入は禁止
```

---

## 7. 未使用警告

### 7.1 `out`/`ref` パラメータの未使用

`out` または `ref` として宣言された tree パラメータが、tree 内で一度も書き込み操作（代入または
`out`/`ref` として渡す）に使用されない場合、警告が発生します。

---

## 8. Nullable型の安全な使用

Nullable 型 (`T?`) を安全に使用するための機構を定義します。

### 8.1 Guard デコレータ（スマートキャスト）

`Guard` は、変数が `null` でないことを保証し、制御フローをガードする**組み込みデコレータ**です。

**動作:**

- 引数に指定された変数がすべて非 `null` の場合、子ノードを実行し、その結果を返す
- いずれかが `null` の場合、子ノードを実行せず即座に `Failure` を返す

### 8.2 型の絞り込み（Type Narrowing）

`Guard` デコレータの子ノードブロック内において、引数として渡された `T?` 型の変数は、自動的に **`T`
型（非Nullable）** として扱われます。

```bt-dsl
var target: Pose? = null;

Fallback {
    @[Guard(target)]
    Sequence {
        // 【スマートキャスト有効】
        // このブロック内では target は Pose 型として扱える
        MoveTo(target)
    },

    // ここでは target は Pose?（null の可能性あり）のまま
    Log("Target is null")
}
```

### 8.3 Nullable変数の `out` ポートへの接続

`T?` 型の変数を `out T`（非Nullable を出力するポート）に渡すことを許可します。

| アクション結果 | 変数の状態                                      |
| :------------- | :---------------------------------------------- |
| 成功           | 変数に値 `T` が書き込まれ、非 `null` 状態になる |
| 失敗           | 変数は元の値（`null` など）のまま維持される     |

```bt-dsl
extern action FindTarget(out result: Pose);

tree Main() {
    var target = null;  // Pose?

    Sequence {
        // 成功すれば target に Pose が入る
        // 失敗すれば target は null のまま
        FindTarget(result: out target),

        // null チェックしてから使用
        @[Guard(target)]
        Use(target)
    }
}
```

> [!NOTE] 詳細は[初期化安全性](./initialization-safety.md)を参照してください。

---

## 9. Import の解決

### 9.1 パス形式

import 文字列は以下のいずれかの形式でなければなりません：

- **相対パス**: `./` または `../` で始まるパス
- **パッケージパス**: 上記以外（例: `pkg_name/path/to/file.bt`）

### 9.2 解決規則

**相対パスの場合:**

1. import 文を含むファイルのディレクトリを基準とする
2. `.` および `..` セグメントを正規化する
3. 解決されたパスのファイルを読み込む

**パッケージパスの場合:**

1. パスの最初のセグメントをパッケージ名として扱う
2. ROS のパッケージパス解決メカニズムを用いてパッケージのルートディレクトリを特定する
3. 残りのパスをパッケージルートからの相対パスとして結合する
4. 解決されたパスのファイルを読み込む

共通の処理として: 5. 読み込んだファイル内の **Public なシンボルのみ** を現在のスコープに取り込む

> [!IMPORTANT] Private なシンボル（`_` で始まる名前）はインポートされません。

### 9.3 インポートの非推移性

`import`
は推移的ではありません。すなわち、ファイル A がファイル B をインポートし、ファイル B がファイル C をインポートしている場合でも、ファイル A からファイル C のシンボルは参照できません。ファイル C のシンボルを使用するには、ファイル A でも明示的にファイル C をインポートする必要があります。

### 9.4 シンボルの衝突

インポートされたシンボルは、現在のファイル内で定義されたシンボルと同様に扱われます。そのため、以下の場合はコンパイルエラーとなります：

| 衝突の種類                       | 例                                                                        |
| :------------------------------- | :------------------------------------------------------------------------ |
| インポートと現在のファイルの定義 | ファイル A が `tree Foo` を定義し、インポート先にも `tree Foo` が存在する |
| 複数のインポート間               | ファイル B と C の両方に `tree Bar` があり、両ファイルをインポートした    |

> [!NOTE] 名前空間が異なるシンボル（例: `extern type X` と
> `tree X`）は衝突しません（[1.3 重複の禁止](#_1-3-重複の禁止)を参照）。
