# 5. 意味論: 実行モデル（Semantics: Execution Model）

本章は、BT-DSL が規定する範囲でのランタイム挙動を定義します。

> [!IMPORTANT]
> ここでいう「実行」は、BT-DSL が生成する BehaviorTree 構造と、ノード呼び出し規約に関する意味論です。個々の
> `extern action` の内部副作用（ロボットを動かす等）はホスト実装に依存します。

---

## 5.1 データモデル（Data Model）

### 5.1.1 Blackboard

- `var` により宣言されるエントリを **Blackboard エントリ** と呼びます。
- Blackboard エントリは、一般的な言語の「スタック変数」とは異なり、**tick 間で値が保持**されます。

> [!IMPORTANT]
> Blackboard エントリは、必ずしも「識別子（名前）文字列」をキーとして同一視されるとは限りません。
> すなわち、Blackboard 名（`var` の識別子）はツリー内で一意である必要はありません。
> 一方で、名前解決の曖昧性を防ぐため、親スコープの同名識別子を隠蔽する **シャドウイングは禁止**です（4.2.3）。
> これにより、任意の参照位置において識別子は高々 1 つの宣言へ解決されます。

### 5.1.2 ライフタイム（Tick 間の永続性）

- `children_block` 内で宣言された `var`
  であっても、値は Tree 全体で保持され、tick 間で破棄されません。

> [!IMPORTANT]
> **可視性（名前解決）はブロックに従い、寿命（保存される値）はツリーに従います。**
> つまり、`children_block` を抜けるとその `var` 名は参照できませんが、対応する Blackboard エントリの値は Tree の寿命の間保持されます。

> [!NOTE]
> これは BehaviorTree.CPP の blackboard モデルに整合させる設計です。

### 5.1.3 コピーと参照（Copy vs Reference）

- `in` は「スナップショット入力」を意味し、論理的には**値渡し**です。
- `ref` は「ライブ参照（読み取り）」を意味し、論理的には**参照渡し（読み取り専用）** です。
- `mut` は「ライブ参照（読み書き）」を意味し、論理的には**参照渡し（読み書き）** です。
- `out` は「出力（成功時のみ書き込み保証）」を意味し、論理的には**書き込み専用参照**です。

> [!NOTE]
> 実メモリのコピー有無は最適化により処理系が変更し得ますが、観測可能な意味論は上記に従います。

---

## 5.2 ノードインターフェース（Node Interface）

### 5.2.1 ポート方向の操作権限

| 方向  | 読み取り | 書き込み | 備考                               |
| :---- | :------: | :------: | :--------------------------------- |
| `in`  |    ✓     |    ✗     | 開始時点の入力（スナップショット） |
| `ref` |    ✓     |    ✗     | 実行中も変化を観測し得る（ライブ） |
| `mut` |    ✓     |    ✓     | 状態共有・更新                     |
| `out` |    ✗     |    ✓     | **成功時のみ**書き込みが保証される |

> [!IMPORTANT]
> `out`
> の書き込み保証は「静的解析と安全性」で厳密に扱います（[初期化安全性](./static-analysis-and-safety.md#_6-1-初期化安全性initialization-safety)）。

### 5.2.2 実行ステータス

BT-DSL のノード実行は、少なくとも次のステータスを持ちます。

- `Success`
- `Failure`
- `Running`
- `Skip`

> [!NOTE]
> `Skip` の導入は BehaviorTree.CPP v4 のスキップ概念に整合します。
>
> 本仕様では、`Skip` は **`Success` とほぼ同等**に扱われます。
> 典型的には親（control/decorator）は `Skip` を受け取った場合、`Success` と同様に「次の子へ進む」等の処理を行います。
>
> ただし、最終的な伝播則（親が `Skip` を `Success` と同一視するか、独自に扱うか）は **ノード実装依存** です。
> 一方で、`#[behavior(DataPolicy, FlowPolicy)]` によって規定されているルール（初期化安全性・兄弟間可視性など）に反しないよう、処理系およびノード実装はそれらのルールに従わなければなりません。

---

## 5.3 制御フロー（Control Flow）

### 5.3.1 Tick

- Tree は外部から繰り返し **tick** されます。
- 1 tick で実行されるノードの順序は、構文上の子列と、`#[behavior(DataPolicy, FlowPolicy)]`
  によって規定されます。

### 5.3.2 Behavior Policies

`#[behavior(DataPolicy, FlowPolicy)]` は、主に次を規定します。

- **DataPolicy**: 親が成功したときに、子による書き込み保証をどう集約するか（静的解析に影響）
- **FlowPolicy**: 兄弟間で書き込み結果が次の子の入力として可視かどうか（静的解析に影響）

詳細な定義は [初期化安全性](./static-analysis-and-safety.md#_6-1-初期化安全性initialization-safety)
を参照してください。

### 5.3.3 事前条件（Preconditions）

事前条件はノードの実行前（および一部は実行中）に評価される組み込み構文です。

| 構文                | 動作                                                                                                                | 偽の時のステータス   |
| :------------------ | :------------------------------------------------------------------------------------------------------------------ | :------------------- |
| `@success_if(cond)` | 条件が真なら **ノード本体の実行をスキップ**し `Success` を返す（Skip and return SUCCESS, if the condition is true） | 通常どおり実行       |
| `@failure_if(cond)` | 条件が真なら **ノード本体の実行をスキップ**し `Failure` を返す                                                      | 通常どおり実行       |
| `@skip_if(cond)`    | 条件が真なら **ノード本体の実行をスキップ**し `Skip` を返す                                                         | 通常どおり実行       |
| `@run_while(cond)`  | 実行前・実行中に条件を評価。偽になった場合、実行を中断し `Skip` を返す                                              | （真の間は）実行継続 |
| `@guard(cond)`      | 実行前・実行中に条件を評価。偽になった場合、実行を中断し `Failure` を返す                                           | （真の間は）実行継続 |

> [!NOTE]
> 複数の事前条件が指定された場合の評価順序は **実装定義** です。

> [!IMPORTANT]
> 事前条件によりノード本体の実行がスキップされた場合、そのノード本体が持つ副作用（`out` への書き込み等）は発生しません。
> 初期化安全性（6.1）における `out` の書き込み保証も、この「ノード本体が実行された場合」に限って適用されます。

---

## 5.4 構文糖衣の脱糖（Desugaring）

本節は「同等変換（desugaring）」を規定します。処理系は、次の変換を行った結果と**等価**な意味論を持たなければなりません。

### 5.4.1 Decorator の暗黙 Sequence

- `decorator` ノードの `children_block` に 2 つ以上の子が書かれた場合、暗黙に `Sequence`
  でラップされます。

```bt-dsl
// 入力
Retry(n: 3) {

  TaskA();
  TaskB();
}

// 脱糖後（概念的）
Retry(n: 3) {

  Sequence {
    TaskA();
    TaskB();
  }
}
```

### 5.4.2 Blackboard 宣言・代入のアクション化

- `var x = expr;` および `x = expr;` は、概念的に「Blackboard 書き込みを行い常に `Success`
  を返すアクション」と等価に扱われます。

特性:

- 返り値は常に `Success`
- 実行順序は `children_block` 内での記述順
- 実行された時点で Blackboard に値が書き込まれる
