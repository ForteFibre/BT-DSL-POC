# 4. 意味論: 宣言とスコープ（Semantics: Declarations and Scopes）

本章は、プログラムの静的構造に関する意味論（宣言、名前空間、スコープ、名前解決、可視性）を定義します。

---

## 4.1 名前空間と可視性（Namespaces and Visibility）

### 4.1.1 名前空間の分離

BT-DSL は少なくとも次の名前空間を持ち、互いに衝突しません。

- **Type 空間**: 基本型、`extern type`、`type`（エイリアス）
- **Node 空間**: `extern` ノード名、`tree` 名
- **Value 空間**: Blackboard（`var`）、定数（`const`）、パラメータ

> [!NOTE]
> 同名でも名前空間が異なれば共存できます（例: `extern type A;` と `tree A()`）。

### 4.1.2 可視性（Visibility）

ファイル間参照（import）における可視性は、識別子の命名規則で規定します。

| 識別子の先頭文字     | 可視性      | 説明                                                       |
| :------------------- | :---------- | :--------------------------------------------------------- |
| `_` (アンダースコア) | **Private** | 定義されたファイル内でのみ参照可能。外部からは見えません。 |
| その他               | **Public**  | `import` した他ファイルから参照可能。                      |

> [!IMPORTANT]
> `import` のうち、パッケージ形式の解決や検索パス等は **実装定義** です。
> 一方で本仕様は、可視性（Public/Private）と基本制約（絶対パス禁止・拡張子必須・相対パスの基準・非推移的可視性）を規定します。

### 4.1.3 import の解決（Module Resolution）

本仕様における `import` は「他モジュールのトップレベル定義（Type / Node / Value 空間）を、現在のモジュールから参照可能にする」ための機構です。

#### 規範（本仕様が規定すること）

- **可視性**: import によって参照できるのは、取り込まれたモジュールの **Public** な宣言（4.1.2）のみです。
  Private（先頭 `_`）は参照できません。

- **パス形式**:
  - **絶対パスは禁止**（先頭が `/` のパスはコンパイルエラー）。
  - **拡張子は必須**（例: `"./foo.bt"` は可、`"./foo"` は不可）。
  - `./` または `../` で始まる相対パスは、**import を記述したファイルのディレクトリ**基準で解決されなければなりません。
  - それ以外の形式（例: `"aaa/bbb.bt"`）はパッケージ形式として扱い、その解決は実装定義です。

- **非推移的（non-transitive）**:
  - 参照できるのは **直接 import したモジュール**の宣言のみです。
  - import 先がさらに import した宣言は可視になりません。

- **曖昧性（ambiguous）**:
  - 同一名前空間（Type / Node / Value）において、同名の Public 宣言が複数の直接 import から導入され、
    それらが参照位置で同時に候補となる場合、当該参照は **曖昧**であり **コンパイルエラー**としなければなりません。

> [!NOTE]
> 例えば複数の import 元がそれぞれ `extern type Pose;` を定義していて、参照位置で `Pose` が一意に解決できない場合、
> `Pose` の参照は曖昧としてコンパイルエラーです。

---

## 4.2 スコープと名前解決（Scopes and Name Resolution）

### 4.2.1 スコープ階層

| スコープ      | 含まれる宣言（代表例）                                            |
| :------------ | :---------------------------------------------------------------- |
| グローバル    | `extern`、`extern type`、`type`、グローバル `var`/`const`、`tree` |
| Tree ローカル | tree パラメータ、ローカル `var`/`const`                           |
| ブロック      | `children_block` 内の `var`/`const`、インライン `out var`         |

### 4.2.2 名前解決の優先順位

識別子の解決は次の順序で行われます。

1. ブロックスコープ（`children_block` 内の `var`/`const`）
2. Tree ローカル（パラメータ、ローカル `var`/`const`）
3. グローバル（当該ファイルのトップレベル `var`/`const` および **直接 import したモジュール**の Public `var`/`const`）

上記の優先順位で候補集合を決定した結果、同一名前空間において **複数の候補が残る**場合（例: 複数 import 由来で同名が見える場合）、
識別子の参照は **曖昧（ambiguous）** であり **コンパイルエラー**としなければなりません。

> [!NOTE]
> Type 空間および Node 空間についても同様に扱われます。import は非推移的（4.1.3）です。

### 4.2.3 重複とシャドウイング

- 同一スコープ内で同名の宣言はできません。
- 親スコープの同名識別子の隠蔽（シャドウイング）は **禁止** です。

> [!NOTE]
> シャドウイング禁止は「入れ子（祖先関係）にあるスコープ間で同名を許さない」ことを意味します。
> したがって、互いに祖先関係にない別スコープ（例: 別 `children_block`）で同名を用いることは許容され得ます。
> （Blackboard 名の一意性は要求されません。実行時のエントリ同一性は実行モデルで規定します。）

同一スコープ内で禁止される代表的な重複は次のとおりです。

- **Type 空間**: `extern type` 同士 / `type` 同士 / `extern type` と `type` / 基本型名との衝突
- **Node 空間**: `extern` ノード同士 / `tree` 同士 / `extern` と `tree`
- **Value 空間**: 同一スコープ内の `var`/`const`/パラメータ同士

> [!IMPORTANT]
> 名前空間が異なる場合は衝突しません（例: `extern type A;` と `tree A()`）。

### 4.2.4 宣言前参照

- ブロックスコープ（tree 本体内）の Value 空間（`var`/`const`/パラメータ）の参照は、**宣言以降**でなければなりません。
- モジュールスコープ（トップレベル）の定義は **定義順序が自由**であり、Type / Node 空間（`extern type` / `type` / `extern` / `tree`）およびトップレベル `const` は **前方参照を許可**します。

> [!NOTE]
> 前方参照が許可される場合でも、同一名前空間の重複定義はコンパイルエラーです。また `const` 参照は循環があるとコンパイルエラーです。

---

## 4.3 定数評価（Constant Evaluation）

### 4.3.1 定数式

- `const` の初期化式、および `extern`/`tree` のデフォルト引数は `const_expr` でなければなりません。
- `const_expr` は **構文上は** `expression` と同じ形を取り、**意味論として**「コンパイル時に評価可能である」ことが要求されます。

### 4.3.2 参照可能な識別子

- `const_expr` 内の `identifier` は、`const`（コンパイル時定数）として解決されなければなりません。
- `const` の参照は前方参照を許可します。
- 循環参照は **コンパイルエラー** です。

### 4.3.3 コンパイル時評価の制約

- `const_expr` は、実行時値（Blackboard、`out` の結果など）を参照してはなりません。
- コンパイル時評価において、数値演算のオーバーフローが発生する場合は **コンパイルエラー**とします。

### 4.3.4 `const_expr` の定義（規範）

`const_expr` は、構文上は `expression` と同じ形を取り得ますが、意味論として「**コンパイル時に完全評価できる**」式に限られます。
少なくとも次を満たさなければなりません。

- **参照制約**: `const_expr` 内の `identifier` は `const` として解決されなければなりません（4.3.2）。
- **実行時値の禁止**: Blackboard（`var`）や tree パラメータ等の実行時値を参照してはなりません（4.3.3）。

#### 最低保証（処理系が必ず受理すべき形）

処理系は、少なくとも次の形を `const_expr` として受理し、評価できなければなりません。

- リテラル（数値/真偽値/文字列/`null`）
- `const` 参照（`const` として解決される `identifier`）
- 括弧: `( const_expr )`
- 単項: `! const_expr`、`- const_expr`
- 二項（両辺が `const_expr` の場合）: `+ - * / %`、`< <= > >=`、`== !=`、`&& ||`、`& |`
- キャスト: `const_expr as type`（ただしキャスト先に `extern type` は不可）
- 配列リテラル: `[...]`
  - `element_list` の各要素は `const_expr`
  - `repeat_init`（`[e; N]`）では `e` と `N` は `const_expr` で、`N` は非負整数に評価できなければならない

#### 禁止（最低要請）

- `vec![...]` や `as vec<_>` を含む **動的配列の構築**は `const_expr` として禁止します。

#### エラー条件（最低保証）

処理系は少なくとも次の場合にコンパイルエラーを報告しなければなりません。

- 0 除算
- `string<N>` や `[T; <=N]` など、型に付随する上限制約に違反する値が定数評価で確定した場合
- 数値型へのキャスト/決定後に、定数値が表現範囲に収まらない場合

> [!NOTE]
> 実行時における評価順序・オーバーフロー/丸め等の詳細は **規定しません**。
> これらは処理系および実行環境に依存します（implementation-defined）。
