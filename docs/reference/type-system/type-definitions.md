# 3.1 型の定義（Type Definitions）

本ドキュメントは、BT-DSL における型（Type）の集合を規定します。

> [!NOTE]
> 型の **表記（構文）** は [構文](../syntax.md#_2-3-型の構文type-syntax)
> を参照してください。本章は、その表記が意味する **型の構造** を規範的に定義します。

---

## 3.1.1 基本型（Primitive Types）

BT-DSL は次の基本型を持ちます。

### 3.1.1.1 整数型

- 符号付き: `int8`, `int16`, `int32`, `int64`
- 符号なし: `uint8`, `uint16`, `uint32`, `uint64`

各整数型のビット幅は、型名末尾の数値に等しい固定値です。

> [!IMPORTANT]
> 数値の表現（2の補数など）やオーバーフロー時の数値意味論は、**本章では規定しません**。ただし 3.3 の互換性/変換規則、および 3.4 の式型規則に反してはなりません。

### 3.1.1.2 浮動小数型

- `float32`
- `float64`

### 3.1.1.3 真偽値

- `bool`

値は `true` / `false` の 2 値です。

### 3.1.1.4 文字列

- `string`
- 上限付き文字列 `string<=N`

`string` は UTF-8 文字列です。

`string<=N` は「最大 $N$ **バイト**」の文字列型です。

ここでの $N$ は、文字列値を UTF-8 として符号化したときの**バイト数**を表します。

- `len_bytes(s)` を文字列 $s$ の UTF-8 バイト長とするとき、`string<=N` の値は常に
  $len\_bytes(s) \le N$ を満たさなければなりません。
- 文字列リテラルの場合、エスケープを解釈した後の値に対して $len_bytes$ を計算します。

---

## 3.1.2 配列型（Array Types）

### 3.1.2.1 静的配列（Static Arrays）

静的配列型は 2 種類あります。

- 固定長: `[T; N]`
- 上限付き: `[T; <=N]`

ここで:

- $T$ は要素型
- $N$ は**非負の整数**であり、コンパイル時に定数として決定できなければなりません

> [!IMPORTANT]
> 構文上は `N` に識別子を置けます（例:
> `[int32; SIZE]`）。この場合、その識別子は「コンパイル時定数として評価可能な整数」を参照しなければなりません。

#### 固定長 `[T; N]`

- `[T; N]` の値は、ちょうど $N$ 個の $T$ を保持します。

#### 上限付き `[T; <=N]`

- `[T; <=N]` の値は、最大 $N$ 個までの $T$ を保持します。
- $N$ は型の一部であり、上限値が異なる場合は異なる型です。

> [!IMPORTANT]
> `[T; <=N]` の「現在長（length）」を取得する式や API は、現状 **未規定（TBD）**
> です。

### 3.1.2.2 動的配列（Dynamic Arrays）

- 動的配列型は `vec<T>` です。
- `vec<T>` の値は、実行時に可変長の列として振る舞います。

> [!NOTE]
> `vec<T>` の具体的なメモリ配置やクローン/ムーブのコストは **実装定義** です。

### 3.1.2.3 多次元配列（Multidimensional Arrays）

配列はネストできます。

- `[[T; N]; M]` は「要素が `[T; N]` である固定長配列」
- `vec<vec<T>>` は「要素が `vec<T>` である動的配列（いわゆる jagged array）」

ネスト配列の型は、外側から順に型コンストラクタを適用して得られる型です。

---

## 3.1.3 Nullable 型（Nullable Types）

Nullable 型 `T?` は、型 $T$ の値または `null` を取り得る型です。

- `T`（非 Nullable）に `null` を代入することはできません。
- `T?`（Nullable）には `null` を代入できます。

> [!NOTE]
> Nullable の安全な使用（`@guard` 等による絞り込み）は 6 章で規定します。

---

## 3.1.4 型エイリアス（Type Aliases）

`type Name = T;` により、型 $T$ に対する別名 `Name` を定義できます。

- エイリアスは**透過的**でなければなりません。
- すなわち、型検査・互換性・推論において `Name` と `T` は区別されません。

### 3.1.4.1 組み込みエイリアス

処理系は利便性のため、少なくとも次のエイリアスを提供してよいものとします。

| エイリアス      | 実体型    |
| :-------------- | :-------- |
| `byte` / `char` | `uint8`   |
| `int`           | `int32`   |
| `float`         | `float32` |
| `double`        | `float64` |

> [!NOTE]
> これらのエイリアスの提供有無を仕様として固定するかは未確定（TBD）です。提供しない処理系は、診断で明示して構いません。

> [!IMPORTANT]
> エイリアスの循環定義（例: `type A = B; type B = A;`）は禁止されます。

---

## 3.1.5 外部型（External / Opaque Types）

`extern type` により導入される型は **不透明型（Opaque Type）** です。

- BT-DSL からは内部構造にアクセスできません（フィールドアクセス等は不可）。
- 外部型の互換性は「同一名の外部型同士」に限定されます（詳細は 3.3）。

---

## 3.1.6 推論用内部型（Internal Inference Types）

以下は型推論にのみ出現する内部型であり、ソースコード上の型としては現れません。

- `{integer}`: 任意の整数型に解決可能な整数リテラル型（デフォルト解決: `int32`）
- `{float}`: 任意の浮動小数型に解決可能な浮動小数リテラル型（デフォルト解決: `float64`）
- `?`: 未解決の型変数
