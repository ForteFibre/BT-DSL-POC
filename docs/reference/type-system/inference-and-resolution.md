# 3.2 型推論と決定（Inference and Resolution）

本ドキュメントは、明示的な型注釈がない場合に処理系が型を決定する推論プロセスを規定します。

---

## 3.2.1 リテラルの型推論

リテラルは型推論プロセスで特別な扱いを受けます。

| リテラル種別     | 例              | 初期型      | デフォルト解決 |
| :--------------- | :-------------- | :---------- | :------------- |
| 整数リテラル     | `42`, `-7`, `0` | `{integer}` | `int32`        |
| 浮動小数リテラル | `3.14`, `-0.5`  | `{float}`   | `float64`      |
| 文字列リテラル   | `"hello"`       | `string`    | `string`       |
| 真偽値リテラル   | `true`, `false` | `bool`      | `bool`         |
| `null` リテラル  | `null`          | `_?`        | 文脈から推論   |

### 数値リテラル

- 整数リテラルは内部型 `{integer}` として型付けされます。
- 浮動小数リテラルは内部型 `{float}` として型付けされます。

`{integer}` / `{float}` は、その使用文脈から具体的な数値型へ解決されます。

- `{integer}` のデフォルト解決型は `int32`
- `{float}` のデフォルト解決型は `float64`

### `null` リテラル

`null` は、型構文のワイルドカード `_?` と同様に「ベース型が未解決で、Nullable であることだけが確定した型」として扱われます。

- `null` のベース型 $T$ は、後続の使用から推論されます。
- スコープ終了までにベース型を一意に決定できない場合、処理系は型エラーを報告しなければなりません。

> [!NOTE]
> `_` や `_?` は構文上のワイルドカード（型推論要求）であり、内部型
> `?`（型変数）とは別物です。

### 配列リテラル

- 通常の配列リテラル `[...]` は **デフォルトで静的配列**として推論されます。

| リテラル構文   | 推論される型 |
| :------------- | :----------- |
| `[e1, e2, e3]` | `[T; 3]`     |
| `[e; N]`       | `[T; N]`     |

> [!IMPORTANT]
> `[...]` が静的配列として推論されるためには、反復初期化 `[e; N]` の `N` は `const_expr`（コンパイル時評価可能）でなければなりません。
> `N` が `const_expr` でない場合、処理系は型エラーを報告しなければなりません。

- `vec![...]` は **動的配列**として推論されます。

| リテラル構文    | 推論される型 |
| :-------------- | :----------- |
| `vec![e1, ...]` | `vec<T>`     |
| `vec![e; N]`    | `vec<T>`     |

> [!IMPORTANT]
> 上限付き静的配列 `[T; <=N]`
> はリテラルからは推論されません。必要なら型注釈で指定し、その型として検査されなければなりません。

### 上限付き型に対する文脈型付け（Contextual Typing）

上限付き型が要求される文脈（代入ターゲットや引数型など）では、リテラルはその型として型付けされ、制約が検査されます。

例:

- 期待型が `[T; <=N]` のとき、`[e1, ..., ek]` は `[T; <=N]` として型付けされ、$k \le N$
  が検査されます。
- 期待型が `string<N>` のとき、`"..."` は `string<N>`
  として型付けされ、UTF-8 バイト長の制約が検査されます。

> [!IMPORTANT]
> ここで検査される長さは 3.1.1.4 のとおり **UTF-8 のバイト数**です。

---

## 3.2.2 型推論ワイルドカード（`_` / `_?`）

型構文中の `_` は「その位置の型を推論せよ」という要求を表します。

- `_` は非 Nullable な型へ解決されます。
- `_?` は Nullable 型へ解決されます。

例:

- `vec<_>`: 要素型を推論する
- `[_; 5]`: 要素型を推論し、サイズは 5 に固定する
- `var x: _? = 1.0;`: `x` を Nullable にしたい（後で `null` を代入したい）ため、ベース型を推論して
  `T?` とする

> [!IMPORTANT]
> `_` / `_?` は「推論要求」であり、内部型 `?`（未解決型変数）そのものではありません。

---

## 3.2.3 推論アルゴリズム（制約に基づく双方向推論）

処理系は、少なくとも次の高水準手順で推論を行わなければなりません。

1. **初期型の付与**: 型注釈なしの `var` / `const` 宣言は、初期値があればその式型から開始し、初期値がなければ未解決型変数 `?` から開始します。数値リテラルは `{integer}` / `{float}` から開始します。

1. **制約の収集**: 代入、引数渡し、演算子適用などの各地点で、型同士の関係（等式制約・部分順序制約など）を収集します。

1. **制約解決（Resolution / Unification）**: 収集された制約を同時に満たす型を探索し、未解決要素（`?`、`{integer}`、`{float}`、および `_`/`_?`/`null` 由来の未解決部分）を具体型へ解決します。

1. **デフォルト適用（Defaulting）**: スコープ終了までに `{integer}` / `{float}` が解決できない場合、デフォルト型へ解決します（それぞれ `int32` / `float64`）。

### 3.2.3.1 共通上位型の解決（Common Supertype Resolution）

複数の制約（代入元、引数、分岐など）から制約を受ける推論変数について、処理系はそれら全ての制約を満たす**共通の上位型（Common Supertype）**を探索しなければなりません。

定義:
制約として与えられた型の集合 $\{T_1, T_2, ..., T_n\}$ に対し、解決結果の型 $C$ は以下を満たす $C$ のうち、最も具体的（縮小）なものでなければなりません（Least Upper Bound）。

1. $\forall i, T_i \preceq C$ （全ての $T_i$ は $C$ へ「安全に拡大変換」可能である）
2. 「安全な拡大変換」の定義は [3.3.3 暗黙の型変換](../type-system/compatibility-and-conversion.md#333-暗黙の型変換implicit-coercion) に準拠します。

規則:

- **整数型の拡大**: 異なる整数型（例: `int8` と `int16`）が制約となる場合、それらを包含する最小の整数型（`int16`）へ解決されます。
- **浮動小数型の拡大**: `float32` と `float64` は `float64` へ解決されます。
- **不適合によるエラー**: 共通の上位型が存在しない場合（例: `int` と `bool`、`int` と `float`）、処理系はこれを解決不能な制約として扱い、型エラーを報告しなければなりません。

> [!IMPORTANT]
> 混合演算の文脈などで `int` と `float` が混在する場合、BT-DSL は厳密性を重視し、暗黙の共通型推論を行いません（明示的なキャストが必要です）。

> [!IMPORTANT]
> デフォルト適用の対象は `{integer}` / `{float}` に限られます。
> スコープ終了時点で未解決の型変数 `?` が残っている場合（`_` / `_?` / `null` に由来するものを含む）、処理系は型エラーを報告しなければなりません。

> [!IMPORTANT]
> 推論により具体型へ解決された結果、リテラル値がその型の表現範囲に収まらない場合、処理系は型エラーを報告しなければなりません。

---

## 3.2.4 Blackboard / 定数の型決定

### `var` 宣言の優先順位

`var` 宣言の型は次の優先順位で決定されます。

1. 型注釈がある場合: 注釈型を採用
2. 初期値がある場合: 初期値式の型から推論
3. 両方ある場合: 型注釈を優先し、初期値がその型に代入可能であることを検査
4. どちらも無い場合:
   - ローカル（tree / block）では「未解決型変数」から開始し、使用箇所から制約を収集して解決してよい
   - グローバルでは型を決定できないためエラー（後述）

### グローバル `var` の制約

- グローバル `var` は **型注釈または初期値**のいずれかを必ず持たなければなりません。
- どちらも無い場合、処理系はエラーを報告しなければなりません。

### `const` 宣言

- `const` は初期化必須です。
- 初期値は `const_expr` でなければなりません。
  - `const_expr` は構文上は `expression` と同じ形を取りますが、意味論として「コンパイル時評価可能」である必要があります。
  - 詳細は [意味論: 宣言とスコープ - 定数評価](../declarations-and-scopes.md#_4-3-定数評価constant-evaluation) を参照してください。

`const` の型決定は `var` と同様に、型注釈があればそれを優先し、なければ初期値から推論します。

### 配列サイズにおける識別子

静的配列のサイズ部に識別子を用いる場合（構文:
`array_size = integer | identifier`）、その識別子は次を満たさなければなりません。

- 参照先は `const` である
- 参照先は整数型へ解決可能である
- 参照先の値はコンパイル時に確定している
