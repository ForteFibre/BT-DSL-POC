# 3.2 型推論と決定（Inference and Resolution）

本ドキュメントは、明示的な型注釈がない場合に処理系が型を決定する推論プロセスを規定します。

---

## 3.2.1 リテラルの型推論

リテラルは型推論プロセスで特別な扱いを受けます。

| リテラル種別     | 例              | 初期型      | デフォルト解決 |
| :--------------- | :-------------- | :---------- | :------------- |
| 整数リテラル     | `42`, `-7`, `0` | `{integer}` | `int32`        |
| 浮動小数リテラル | `3.14`, `-0.5`  | `{float}`   | `float64`      |
| 文字列リテラル   | `"hello"`      | `string`    | `string`       |
| 真偽値リテラル   | `true`, `false` | `bool`      | `bool`         |
| `null` リテラル  | `null`          | `_?`        | 文脈から推論   |

### 数値リテラル

- 整数リテラルは内部型 `{integer}` として型付けされます。
- 浮動小数リテラルは内部型 `{float}` として型付けされます。

`{integer}` / `{float}` は、その使用文脈から具体的な数値型へ解決されます。

- `{integer}` のデフォルト解決型は `int32`
- `{float}` のデフォルト解決型は `float64`

### `null` リテラル

- `null` は内部的に「未解決 Nullable 型」 `_?` として扱われます。
- `_?` のベース型 $T$ は、後続の使用から推論されます。

> [!NOTE]
> `_` や `_?` は構文上のワイルドカード（型推論要求）であり、内部型 `?`（型変数）とは別物です。

### 配列リテラル

- 通常の配列リテラル `[...]` は **デフォルトで静的配列**として推論されます。

| リテラル構文    | 推論される型   |
| :-------------- | :------------- |
| `[e1, e2, e3]`  | `[T; 3]`       |
| `[e; N]`        | `[T; N]`       |

- `vec![...]` は **動的配列**として推論されます。

| リテラル構文    | 推論される型   |
| :-------------- | :------------- |
| `vec![e1, ...]` | `vec<T>`       |
| `vec![e; N]`    | `vec<T>`       |

> [!IMPORTANT]
> 上限付き静的配列 `[T; <=N]` はリテラルからは推論されません。必要なら型注釈で指定し、その型として検査されなければなりません。

### 上限付き型に対する文脈型付け（Contextual Typing）

上限付き型が要求される文脈（代入ターゲットや引数型など）では、リテラルはその型として型付けされ、制約が検査されます。

例:

- 期待型が `[T; <=N]` のとき、`[e1, ..., ek]` は `[T; <=N]` として型付けされ、$k \le N$ が検査されます。
- 期待型が `string<=N` のとき、`"..."` は `string<=N` として型付けされ、UTF-8 バイト長の制約が検査されます。

> [!IMPORTANT]
> ここで検査される長さは 3.1.1.4 のとおり **UTF-8 のバイト数**です。

---

## 3.2.2 型推論ワイルドカード（`_` / `_?`）

型構文中の `_` は「その位置の型を推論せよ」という要求を表します。

- `_` は非 Nullable な型へ解決されます。
- `_?` は Nullable 型へ解決されます。

例:

- `vec<_>`: 要素型を推論する
- `[_; 5]`: 要素型を推論し、サイズは 5 に固定する
- `var x: _? = 1.0;`: `x` を Nullable にしたい（後で `null` を代入したい）ため、ベース型を推論して `T?` とする

> [!IMPORTANT]
> `_` / `_?` は「推論要求」であり、内部型 `?`（未解決型変数）そのものではありません。

---

## 3.2.3 推論アルゴリズム（制約に基づく双方向推論）

処理系は、少なくとも次の高水準手順で推論を行わなければなりません。

1. **初期型の付与**
   - 型注釈なしの `var` / `const` 宣言は、初期値があればその式型から開始し、初期値がなければ未解決型変数 `?` から開始します。
   - 数値リテラルは `{integer}` / `{float}` から開始します。

2. **制約の収集**
   - 代入、引数渡し、演算子適用などの各地点で、型同士の関係（等式制約・部分順序制約など）を収集します。

3. **制約解決（Resolution / Unification）**
   - 収集された制約を同時に満たす型を探索し、未解決要素（`?`、`{integer}`、`{float}`、`_?`）を具体型へ解決します。

4. **デフォルト適用（Defaulting）**
   - スコープ終了までに `{integer}` / `{float}` が解決できない場合、デフォルト型へ解決します（それぞれ `int32` / `float64`）。

> [!IMPORTANT]
> 推論により具体型へ解決された結果、リテラル値がその型の表現範囲に収まらない場合、処理系は型エラーを報告しなければなりません。

---

## 3.2.4 Blackboard / 定数の型決定

### `var` 宣言の優先順位

`var` 宣言の型は次の優先順位で決定されます。

1. 型注釈がある場合: 注釈型を採用
2. 初期値がある場合: 初期値式の型から推論
3. 両方ある場合: 型注釈を優先し、初期値がその型に代入可能であることを検査
4. どちらも無い場合:
   - ローカル（tree / block）では「未解決型変数」から開始し、使用箇所から制約を収集して解決してよい
   - グローバルでは型を決定できないためエラー（後述）

### グローバル `var` の制約

- グローバル `var` は **型注釈または初期値**のいずれかを必ず持たなければなりません。
- どちらも無い場合、処理系はエラーを報告しなければなりません。

### `const` 宣言

- `const` は初期化必須です。
- 初期値は `const_expr` でなければなりません（構文は [構文](../syntax.md#_2-7-定数式constant-expressions)）。

`const` の型決定は `var` と同様に、型注釈があればそれを優先し、なければ初期値から推論します。

### 配列サイズにおける識別子

静的配列のサイズ部に識別子を用いる場合（構文: `array_size = integer | identifier`）、その識別子は次を満たさなければなりません。

- 参照先は `const` である
- 参照先は整数型へ解決可能である
- 参照先の値はコンパイル時に確定している
