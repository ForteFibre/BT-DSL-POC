# 3.4 式の型規則（Expression Typing）

本ドキュメントは、式が評価されたときに得られる型（式の型）を定義します。

本章では、型付け判断を $\Gamma \vdash e : T$ と表記します。

- $\Gamma$ は型環境（識別子 → 型）
- $e$ は式
- $T$ は型

---

## 3.4.1 単項演算

### 算術否定 `-e`

- $\Gamma \vdash e : Int$（任意の整数型）のとき、$\Gamma \vdash -e : Int$
- $\Gamma \vdash e : Float$（`float32` または `float64`）のとき、$\Gamma \vdash -e : Float$

それ以外は型エラーです。

### 論理否定 `!e`

- $\Gamma \vdash e : bool$ のとき、$\Gamma \vdash !e : bool$

それ以外は型エラーです。

---

## 3.4.2 二項演算

### 算術演算（`+`, `-`, `*`, `/`）

数値型同士の演算は、両オペランドを共通の型へ揃えてから行います。

- 共通型は 3.3 の拡大変換（Widening）により到達可能な型のうち、両者を表現できる最小の型でなければなりません。
- その共通型を結果型とします。

特例:

- `string + string` は `string`（文字列連結）

> [!IMPORTANT]
> 符号付き整数と符号なし整数の混在（例: `int32 + uint32`）について、暗黙の共通型は 3.3 に定義されていないため、現状 **型エラー**とします（TBD）。

### 剰余 `%`

- 両オペランドは整数型でなければなりません。
- 結果型は共通型（上記と同様）です。

### 比較（`<`, `<=`, `>`, `>=`）

- 両オペランドは数値型でなければなりません。
- 結果型は常に `bool` です。

### 等価（`==`, `!=`）

- オペランド同士が互換（3.3）でなければなりません。
- 結果型は常に `bool` です。

### 論理（`&&`, `||`）

- 両オペランドは `bool` でなければなりません。
- 結果型は `bool` です。

### ビット演算（`&`, `|`）

- 両オペランドは整数型でなければなりません。
- 結果型は、3.3 の拡大変換により到達可能な共通型（存在する場合）のうち最小の型とします。

---

## 3.4.3 キャスト式

キャスト式 `e as T` は次の規則で型付けされます。

- $\Gamma \vdash e : S$ かつ、3.3.4 の規則に従って $S$ から $T$ への明示的キャストが許容されるとき、$\Gamma \vdash (e \; as \; T) : T$

許容されない場合は型エラーです。

---

## 3.4.4 配列アクセス

配列要素アクセス `arr[index]` は次の規則で型付けされます。

### 要求される型

- $\Gamma \vdash index : I$ が整数型（符号付き/なし）でなければなりません。
- `arr` は `[T; N]`、`[T; <=N]`、または `vec<T>` でなければなりません。

### 結果型

- `arr: [T; N]` のとき、`arr[index] : T`
- `arr: [T; <=N]` のとき、`arr[index] : T`
- `arr: vec<T>` のとき、`arr[index] : T`

### 境界チェック（定数インデックス）

処理系は、次の場合に限り境界チェックをコンパイル時に行わなければなりません。

- 配列が静的配列であり、$N$ がコンパイル時定数
- `index` がコンパイル時定数（定数式として評価可能）

このとき `index` が $0 \le index < N$ を満たさない場合、処理系はコンパイルエラーを報告しなければなりません。

上記以外の場合（例: 実行時に決まる `index`、`vec<T>` など）の境界チェックの有無・例外・未定義動作は **実装定義** です。
